import java.io.{File, PrintWriter, Writer}
import javax.tools.ToolProvider

import org.objectweb.asm.{ClassReader, ClassVisitor, MethodVisitor, Opcodes}
import sbt.Keys._
import sbt._
import sbt.internal.inc.{Analysis, CompilerArguments}
import sbt.internal.util.ManagedLogger
import sbt.plugins.JvmPlugin

import scala.sys.process._
import scala.util.Properties

trait JavahKeys {
  val javah: TaskKey[File] = taskKey[File]("Generator C/C++ header and stub file.")
  val javahOptions: TaskKey[Seq[String]] = TaskKey[Seq[String]]("javah-options", "Options for javah.")
}

object Javah extends AutoPlugin {

  object autoImport extends JavahKeys

  override def requires: Plugins = JvmPlugin
  override def trigger: PluginTrigger = NoTrigger
  override def projectSettings: Seq[Setting[_]] =
    inConfig(Compile)(javahSettings) ++ inConfig(Test)(javahSettings)

  import autoImport._

  def javahSettings: Seq[Setting[_]] = {
    Seq(
      target in javah := sourceDirectory.value / "native",
      javahOptions := Nil,
    ) ++ (if (Properties.isJavaAtLeast("1.8")) {
      // use javac
      Seq(
        javacOptions ++= Seq("-h", (target in javah).value.absolutePath),
        javah := {
          val out = (target in javah).value
          val _ = compile.value
          val s = streams.value
          s.log("Native header is already generated by java compiler.")
          out
        }
      )
    } else {
      // fallback to javah
      Seq(
        javah := {
          val out = (target in javah).value
          val compileResult = compile.value
          val s = streams.value
          val products = compileResult match {
            case analysis: Analysis =>
              val products = analysis.relations.allProducts
              products.flatMap(NativeFinder.find)(collection.breakOut)
            case _ =>
              Set.empty
          }
          val cp = fullClasspath.value.map(_.data)
          val options = javahOptions.value.toList
          val classpathOption = List("-classpath", CompilerArguments.absString(cp))
          val outputOption = List("-d", out.getAbsolutePath)
          val args = options ::: outputOption ::: classpathOption ::: products.toList
          val log = s.log
          var exitCode = -1
          if (products.isEmpty) log.info("No native class available, skipping generating native header...")
          else {
            s.log.info("Generating native header to " + out.absolutePath + "...")
            exitCode = JavahRunner.run(args.toArray, log)
            log.info("Generating native header successful.")
          }
          if (exitCode != 0) {
            throw new RuntimeException(s"javah exit with code: $exitCode")
          }
          out
        }
      )
    })

  }
}

private object JavahRunner {
  private[this] def javahMethod = {
    try {
      val javahClz = Class.forName("com.sun.tools.javah.Main", true, ToolProvider.getSystemToolClassLoader)
      val pw = classOf[PrintWriter]
      val arrStr = classOf[Array[String]]
      Option(javahClz.getDeclaredMethod("run", arrStr, pw))
    } catch { case t @ (_: ClassNotFoundException|_: NoSuchMethodException) =>
        t.printStackTrace()
        None
    }
  }

  def run(
    args: Array[String],
    log: ManagedLogger
  ): Int = {
    javahMethod match {
      case Some(m) =>
        val infoWriter = new PrintWriter(new Writer {
          override def flush(): Unit = ()
          override def close(): Unit = ()
          override def write(cbuf: Array[Char], off: Int, len: Int): Unit = {
            log.log(Level.Info, new String(cbuf, off, len))
          }
        })
        val run = m.invoke(null, args, infoWriter)
        run.asInstanceOf[java.lang.Integer].intValue
      case _ =>
        val cwd = new File(new File(".").getAbsolutePath).getCanonicalFile
        Process("javah" +: args, cwd) ! log
    }
  }
}

class NativeFinder extends ClassVisitor(Opcodes.ASM6) {
  private[this] var name: String = _
  private[this] var isNative: Int = 0

  def result: Option[String] = {
    if (isNative > 0) {
      Some(name.replace(File.separatorChar, '.'))
    } else {
      None
    }
  }

  override def visit(
    version: Int, access: Int, name: String, signature: String,
    superName: String, interfaces: Array[String]
  ): Unit = {
    this.name = name
  }

  override def visitMethod(
    access: Int,
    name: String,
    desc: String,
    signature: String,
    exceptions: Array[String]
  ): MethodVisitor = {
    isNative &= access & Opcodes.ACC_NATIVE
    null
  }

}

object NativeFinder {
  private[this] val Flags = ClassReader.SKIP_CODE|ClassReader.SKIP_DEBUG|ClassReader.SKIP_FRAMES
  def find(file: File): Option[String] = {
    val reader = new ClassReader(IO.readBytes(file))
    val finder = new NativeFinder
    reader.accept(finder, Flags)
    finder.result
  }
}
